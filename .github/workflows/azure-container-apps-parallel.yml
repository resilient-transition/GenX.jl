name: Parallel GenX Jobs on Azure Container Apps
# Updated: 2025-06-09 - Force cache refresh with robust job naming

on:
  workflow_dispatch:
    inputs:
      blob_container:
        description: 'Azure Blob Storage container name (e.g., genx-data)'
        required: true
        type: string
      case_names:
        description: 'Comma-separated list of case names to run (e.g., kentucky,texas,california)'
        required: true
        type: string
      cpu_cores:
        description: 'CPU cores per job (0.25-2.0)'
        required: false
        default: '1.0'
        type: string
      memory_gb:
        description: 'Memory in GB per job (0.5-4.0)'
        required: false
        default: '2.0'
        type: string
      max_parallel:
        description: 'Maximum parallel jobs'
        required: false
        default: '5'
        type: string
      cleanup_level:
        description: 'Cleanup level: jobs-only, registries, or full'
        required: false
        default: 'jobs-only'
        type: choice
        options:
          - jobs-only
          - registries  
          - full
      force_env_recreate:
        description: 'Force Container App Environment recreation (use only for debugging)'
        required: false
        default: false
        type: boolean
      cleanup_registry:
        description: 'Delete Container Registry after run (true/false)'
        required: false
        default: 'true'
        type: string

env:
  AZURE_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
  AZURE_LOCATION: ${{ secrets.AZURE_LOCATION }}
  AZURE_STORAGE_ACCOUNT: ${{ secrets.AZURE_STORAGE_ACCOUNT }}
  AZURE_STORAGE_KEY: ${{ secrets.AZURE_STORAGE_KEY }}
  CONTAINER_REGISTRY: genxregistry
  CONTAINER_APP_ENV: genx-env

jobs:
  setup-infrastructure:
    runs-on: ubuntu-latest
    outputs:
      registry-ready: ${{ steps.registry.outputs.ready }}
      registry-name: ${{ steps.setup-vars.outputs.registry }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup variables
        id: setup-vars
        run: |
          echo "registry=${{ env.CONTAINER_REGISTRY }}" >> $GITHUB_OUTPUT
          echo "üìã Infrastructure Configuration:"
          echo "  Registry: ${{ env.CONTAINER_REGISTRY }}"
          echo "  Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
          echo "  Location: ${{ env.AZURE_LOCATION }}"

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Create or use existing Azure Container Registry
        id: registry
        run: |
          # Check if registry already exists
          if az acr show --name ${{ env.CONTAINER_REGISTRY }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
            echo "‚úÖ Container Registry ${{ env.CONTAINER_REGISTRY }} already exists, reusing it"
            echo "ready=true" >> $GITHUB_OUTPUT
          else
            echo "üèóÔ∏è Creating Container Registry ${{ env.CONTAINER_REGISTRY }}"
            az acr create \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --name ${{ env.CONTAINER_REGISTRY }} \
              --sku Basic \
              --admin-enabled true \
              --location ${{ env.AZURE_LOCATION }}
            echo "‚úÖ Container Registry created successfully"
            echo "ready=true" >> $GITHUB_OUTPUT
          fi

  setup-environment:
    runs-on: ubuntu-latest
    outputs:
      environment-ready: ${{ steps.env-check.outputs.ready }}
      environment-name: ${{ steps.env-check.outputs.name }}
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Check Container App Environment
        id: env-check
        run: |
          echo "üîç Checking Container App Environment ${{ env.CONTAINER_APP_ENV }}"
          if az containerapp env show --name ${{ env.CONTAINER_APP_ENV }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
            echo "‚úÖ Container App Environment ${{ env.CONTAINER_APP_ENV }} exists and ready"
            echo "ready=true" >> $GITHUB_OUTPUT
            echo "name=${{ env.CONTAINER_APP_ENV }}" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Container App Environment ${{ env.CONTAINER_APP_ENV }} not found"
            echo "Please ensure the environment exists before running jobs"
            exit 1
          fi

  setup-matrix:
    runs-on: ubuntu-latest
    outputs:
      case-matrix: ${{ steps.parse-cases.outputs.cases }}
    steps:
      - name: Parse case names into matrix
        id: parse-cases
        run: |
          cases="${{ github.event.inputs.case_names }}"
          # Convert comma-separated string to JSON array (compact format)
          json_array=$(echo "$cases" | jq -R -c 'split(",") | map(select(length > 0) | gsub("^\\s+|\\s+$"; ""))')
          echo "cases=$json_array" >> $GITHUB_OUTPUT
          echo "üìã Parsed cases: $json_array"

  build-image:
    needs: [setup-infrastructure, setup-matrix]
    runs-on: ubuntu-latest
    outputs:
      image-name: ${{ steps.setup-vars.outputs.image }}
      build-needed: ${{ steps.check-build.outputs.build_needed }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup image variables
        id: setup-vars
        run: |
          echo "image=${{ env.CONTAINER_REGISTRY }}.azurecr.io/genx:${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "üìã Image Configuration:"
          echo "  Registry: ${{ env.CONTAINER_REGISTRY }}"
          echo "  Image: ${{ env.CONTAINER_REGISTRY }}.azurecr.io/genx:${{ github.sha }}"
          echo "  Commit: ${{ github.sha }}"

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Check if Docker image build needed
        id: check-build
        run: |
          # Login to ACR first to check for existing images
          az acr login --name ${{ env.CONTAINER_REGISTRY }}
          
          # Check if image with current commit SHA already exists
          IMAGE_EXISTS=$(az acr repository show-tags \
            --name ${{ env.CONTAINER_REGISTRY }} \
            --repository genx \
            --query "contains(@, '${{ github.sha }}')" \
            --output tsv 2>/dev/null || echo "false")
          
          # Check if critical build files have changed in recent commits
          DOCKERFILE_CHANGED=$(git diff --name-only HEAD~3..HEAD | grep -E "(Dockerfile|Project\.toml|Manifest\.toml)" || echo "")
          
          if [ "$IMAGE_EXISTS" = "true" ] && [ -z "$DOCKERFILE_CHANGED" ]; then
            echo "‚úÖ Docker image for commit ${{ github.sha }} already exists and no build dependencies changed"
            echo "skip_build=true" >> $GITHUB_OUTPUT
            echo "reason=image_exists" >> $GITHUB_OUTPUT
            echo "Image already available: ${{ steps.setup-vars.outputs.image }}"
          elif [ "$IMAGE_EXISTS" = "true" ] && [ -n "$DOCKERFILE_CHANGED" ]; then
            echo "üîÑ Image exists but critical files changed: $DOCKERFILE_CHANGED"
            echo "skip_build=false" >> $GITHUB_OUTPUT
            echo "reason=files_changed" >> $GITHUB_OUTPUT
          else
            echo "üî® Docker image for commit ${{ github.sha }} not found, build required"
            echo "skip_build=false" >> $GITHUB_OUTPUT
            echo "reason=image_missing" >> $GITHUB_OUTPUT
            echo "Will build new image: ${{ steps.setup-vars.outputs.image }}"
          fi

      - name: Build and push Docker image
        if: steps.check-build.outputs.skip_build != 'true'
        run: |
          echo "üî® Building Docker image..."
          echo "Reason: ${{ steps.check-build.outputs.reason }}"
          START_TIME=$(date +%s)
          
          # ACR login already done in previous step
          
          # Build and push image
          docker build -t ${{ steps.setup-vars.outputs.image }} .
          docker push ${{ steps.setup-vars.outputs.image }}
          
          END_TIME=$(date +%s)
          BUILD_TIME=$((END_TIME - START_TIME))
          echo "‚úÖ Docker image built and pushed successfully"
          echo "‚è±Ô∏è Build time: ${BUILD_TIME} seconds"

      - name: Skip build notification
        if: steps.check-build.outputs.skip_build == 'true'
        run: |
          echo "‚è≠Ô∏è Skipped Docker build - using existing image"
          echo "Reason: ${{ steps.check-build.outputs.reason }}"
          echo "üí∞ Time saved: ~2-3 minutes"
          echo "üíæ Storage saved: ~500MB-1GB (no duplicate layers)"
          echo "üéØ Using cached image: ${{ steps.setup-vars.outputs.image }}"

      - name: Create Container App Environment
        run: |
          az containerapp env create \
            --name ${{ env.CONTAINER_APP_ENV }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --location ${{ env.AZURE_LOCATION }}

  run-parallel-jobs:
    needs: [setup-infrastructure, setup-environment, setup-matrix, build-image]
    runs-on: ubuntu-latest
    strategy:
      max-parallel: ${{ fromJson(github.event.inputs.max_parallel) }}
      matrix:
        case: ${{ fromJson(needs.setup-matrix.outputs.case-matrix) }}
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Create and run Container App Job
        id: run-job
        run: |
          # Debug: Show initial case name
          echo "=== JOB NAME TRANSFORMATION DEBUG ==="
          echo "Original matrix.case: ${{ matrix.case }}"
          echo "Run number: ${{ github.run_number }}"
          
          # Create Azure-compliant job name (replace underscores with hyphens, ensure < 32 chars)
          CASE_CLEAN=$(echo "${{ matrix.case }}" | tr '_' '-' | tr '[:upper:]' '[:lower:]')
          RUN_NUM="${{ github.run_number }}"
          
          echo "After transformation: $CASE_CLEAN"
          
          # Calculate max case name length (32 - "genx-" - "-" - run_number)
          MAX_CASE_LEN=$((32 - 5 - 1 - ${#RUN_NUM}))
          
          # Truncate case name if too long, keeping meaningful part
          if [ ${#CASE_CLEAN} -gt $MAX_CASE_LEN ]; then
            echo "Case name too long, truncating from ${#CASE_CLEAN} to $MAX_CASE_LEN chars"
            CASE_CLEAN=$(echo "$CASE_CLEAN" | cut -c1-$MAX_CASE_LEN)
          fi
          
          JOB_NAME="genx-${CASE_CLEAN}-${RUN_NUM}"
          
          # Verify final name length and compliance
          echo "Final job name: $JOB_NAME (length: ${#JOB_NAME})"
          echo "=== END DEBUG ==="
          
          if [ ${#JOB_NAME} -gt 32 ]; then
            echo "ERROR: Job name exceeds 32 characters"
            exit 1
          fi
          
          # Get ACR credentials
          ACR_SERVER="${{ needs.setup-infrastructure.outputs.registry-name }}.azurecr.io"
          ACR_USERNAME=$(az acr credential show --name ${{ needs.setup-infrastructure.outputs.registry-name }} --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ needs.setup-infrastructure.outputs.registry-name }} --query passwords[0].value -o tsv)
          
          # Create Container App Job
          az containerapp job create \
            --name "$JOB_NAME" \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --environment ${{ needs.setup-environment.outputs.environment-name }} \
            --image "${{ needs.build-image.outputs.image-name }}" \
            --registry-server "$ACR_SERVER" \
            --registry-username "$ACR_USERNAME" \
            --registry-password "$ACR_PASSWORD" \
            --cpu ${{ github.event.inputs.cpu_cores }} \
            --memory ${{ github.event.inputs.memory_gb }}Gi \
            --env-vars \
              AZURE_STORAGE_ACCOUNT=${{ env.AZURE_STORAGE_ACCOUNT }} \
              AZURE_STORAGE_KEY=${{ env.AZURE_STORAGE_KEY }} \
              BLOB_CONTAINER=${{ github.event.inputs.blob_container }} \
              CASE_NAME=${{ matrix.case }} \
            --parallelism 1 \
            --replica-completion-count 1 \
            --replica-retry-limit 2 \
            --replica-timeout 7200

          # Start the job
          EXECUTION_NAME=$(az containerapp job start --name "$JOB_NAME" --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query name -o tsv)
          echo "execution-name=$EXECUTION_NAME" >> $GITHUB_OUTPUT
          echo "job-name=$JOB_NAME" >> $GITHUB_OUTPUT

      - name: Monitor job execution
        run: |
          JOB_NAME="${{ steps.run-job.outputs.job-name }}"
          EXECUTION_NAME="${{ steps.run-job.outputs.execution-name }}"
          
          echo "Monitoring job: $JOB_NAME, execution: $EXECUTION_NAME"
          
          # Wait for job completion (timeout after 2 hours)
          timeout=7200
          interval=30
          elapsed=0
          
          while [ $elapsed -lt $timeout ]; do
            status=$(az containerapp job execution show \
              --name "$JOB_NAME" \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --execution-name "$EXECUTION_NAME" \
              --query "properties.status" -o tsv 2>/dev/null || echo "Unknown")
            
            echo "[$elapsed s] Job status: $status"
            
            if [ "$status" = "Succeeded" ]; then
              echo "‚úÖ Job completed successfully!"
              exit 0
            elif [ "$status" = "Failed" ]; then
              echo "‚ùå Job failed!"
              exit 1
            fi
            
            sleep $interval
            elapsed=$((elapsed + interval))
          done
          
          echo "‚è∞ Job timed out after $timeout seconds"
          exit 1

      - name: Get job logs
        if: always()
        run: |
          JOB_NAME="${{ steps.run-job.outputs.job-name }}"
          EXECUTION_NAME="${{ steps.run-job.outputs.execution-name }}"
          
          echo "Fetching logs for job: $JOB_NAME, execution: $EXECUTION_NAME"
          
          # Get logs and save to file
          az containerapp job execution show \
            --name "$JOB_NAME" \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --execution-name "$EXECUTION_NAME" \
            --query "properties.template.containers[0].image" -o tsv || true
          
          # Try to get logs
          az containerapp logs show \
            --name "$JOB_NAME" \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --follow false \
            --tail 1000 > "${{ matrix.case }}-logs.txt" || echo "Could not retrieve logs"

      - name: Upload job logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: genx-logs-${{ matrix.case }}
          path: ${{ matrix.case }}-logs.txt
          retention-days: 7

  cleanup:
    needs: [setup-infrastructure, run-parallel-jobs]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Cleanup Azure resources
        run: |
          echo "=== Cleaning up deployment-specific resources ==="
          echo "Cleanup level: ${{ github.event.inputs.cleanup_level }}"
          
          # Always delete Container App Jobs from this run
          echo "Deleting Container App Jobs from this deployment..."
          az containerapp job list \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --query "[?contains(name, 'genx-') && contains(name, '-${{ github.run_number }}')].name" \
            --output tsv | while read job_name; do
            if [ -n "$job_name" ]; then
              echo "Deleting job: $job_name"
              az containerapp job delete \
                --name "$job_name" \
                --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
                --yes || true
            fi
          done
          
          # Container Registry cleanup based on level
          if [ "${{ github.event.inputs.cleanup_level }}" = "full" ]; then
            echo "FULL CLEANUP: Deleting Container Registry '${{ env.CONTAINER_REGISTRY }}'..."
            az acr delete \
              --name ${{ env.CONTAINER_REGISTRY }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --yes || true
          elif [ "${{ github.event.inputs.cleanup_level }}" = "registries" ]; then
            echo "REGISTRY CLEANUP: Cleaning old images from '${{ env.CONTAINER_REGISTRY }}'..."
            # Keep only the 5 most recent images to save storage costs
            az acr repository list --name ${{ env.CONTAINER_REGISTRY }} --output tsv | while read repo; do
              echo "Cleaning old tags from repository: $repo"
              az acr repository show-tags --name ${{ env.CONTAINER_REGISTRY }} --repository "$repo" \
                --orderby time_desc --output tsv | tail -n +6 | while read tag; do
                if [ -n "$tag" ]; then
                  echo "Deleting old tag: $repo:$tag"
                  az acr repository delete --name ${{ env.CONTAINER_REGISTRY }} --image "$repo:$tag" --yes || true
                fi
              done
            done
          else
            echo "Keeping Container Registry '${{ env.CONTAINER_REGISTRY }}' and all images (cleanup_level=${{ github.event.inputs.cleanup_level }})"
          fi
          
          # Container App Environment cleanup (only for full cleanup or force recreate)
          if [ "${{ github.event.inputs.cleanup_level }}" = "full" ] || [ "${{ github.event.inputs.force_env_recreate }}" = "true" ]; then
            echo "WARNING: Deleting Container App Environment '${{ env.CONTAINER_APP_ENV }}'..."
            az containerapp env delete \
              --name ${{ env.CONTAINER_APP_ENV }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --yes || true
          else
            echo "Keeping Container App Environment '${{ env.CONTAINER_APP_ENV }}' for reuse (cleanup_level=${{ github.event.inputs.cleanup_level }})"
          fi

  summary:
    needs: [setup-infrastructure, setup-environment, setup-matrix, build-image, run-parallel-jobs]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Job Summary
        run: |
          echo "## GenX Parallel Execution Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Cases processed:** ${{ github.event.inputs.case_names }}" >> $GITHUB_STEP_SUMMARY
          echo "**Container:** ${{ github.event.inputs.blob_container }}" >> $GITHUB_STEP_SUMMARY
          echo "**Resources per job:** ${{ github.event.inputs.cpu_cores }} CPU, ${{ github.event.inputs.memory_gb }}GB RAM" >> $GITHUB_STEP_SUMMARY
          echo "**Max parallel:** ${{ github.event.inputs.max_parallel }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Results location:** Azure Blob Storage container \`${{ github.event.inputs.blob_container }}\` under \`results/\` folder" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Check the logs artifacts for detailed execution information."
